// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Vote
#pragma kernel Scan
#pragma kernel Compact

#define NUM_GROUP_THREADS_X 64
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
StructuredBuffer<float3> PositionsBuffer;
RWStructuredBuffer<int> VoteBuffer;
RWStructuredBuffer<int> ScanBuffer;
RWStructuredBuffer<int> GroupSumsBuffer;
RWStructuredBuffer<int> GroupSumsInBuffer;
RWStructuredBuffer<int> GroupSumsOutBuffer;
RWStructuredBuffer<float3> CulledGrassBuffer;

groupshared uint temp[2 * NUM_GROUP_THREADS_X];
groupshared uint groupSumsTemp[2 * 1024];
float4x4 UNITY_MATRIX_VP;
float3 CameraPosition;
float Distance;
int NumGroups;

bool InRange(float val, float min, float max)
{
    return val < max && val > min;
}

[numthreads(NUM_GROUP_THREADS_X, 1, 1)]
void Vote(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int globalID = int(dispatchThreadID.x);
    float4 pos = float4(PositionsBuffer[globalID].xyz, 1.0f);
    float4 viewSpace = mul(UNITY_MATRIX_VP, pos);
    float3 clipSpace = viewSpace.xyz;
    clipSpace /= -viewSpace.w;
    clipSpace.x = clipSpace.x / 2.0f + 0.5f;
    clipSpace.y = clipSpace.y / 2.0f + 0.5f;
    clipSpace.z = -viewSpace.w;
    bool inView = InRange(clipSpace.x, 0.0f, 1.0f) && InRange(clipSpace.x, 0.0f, 1.0f) && clipSpace.z > 0;
    bool inDistance = distance(CameraPosition, pos.xyz) < Distance;
    VoteBuffer[globalID] = inView * inDistance;
}

[numthreads(NUM_GROUP_THREADS_X,1,1)]
void Scan(uint3 dispatchThreadID : SV_DispatchThreadID, uint groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    int globalID = int(dispatchThreadID.x);
    int localID = int(groupThreadID.x);
    int groupID = int(groupID);
    
    int numElements = NUM_GROUP_THREADS_X;
    temp[globalID] = localID > 0 ? VoteBuffer[globalID - 1] : 0;
    
    GroupMemoryBarrierWithGroupSync();
    for (int offset = 1; offset < numElements; offset <<= 1)
    {
        GroupMemoryBarrierWithGroupSync();
        if (globalID >= offset)
            temp[globalID] += temp[globalID - offset];
    }
    ScanBuffer[globalID] = temp[globalID];
    
    if (localID == 0)
    {
        GroupSumsBuffer[groupID] = temp[numElements - 1];
        temp[numElements - 1] = 0;
    }
    
    ScanBuffer[globalID] = temp[globalID];
}

[numthreads(1024, 1, 1)]
void ScanGroupSums(uint3 dispatchThreadID : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID)
{
    int globalID = int(dispatchThreadID.x);
    groupSumsTemp[globalID] = globalID > 0 ? GroupSumsInBuffer[globalID - 1] : 0;
    
    GroupMemoryBarrierWithGroupSync();
    for (int offset = 1; offset < NumGroups; offset <<= 1)
    {
        GroupMemoryBarrierWithGroupSync();
        if (globalID >= offset)
            groupSumsTemp[globalID] += groupSumsTemp[globalID - offset];
    }
    GroupSumsOutBuffer[globalID] = groupSumsTemp[globalID];
}


[numthreads(NUM_GROUP_THREADS_X, 1, 1)]
void Compact(uint3 dispatchThreadID : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID)
{
    int globalID = int(dispatchThreadID.x);
    if (VoteBuffer[globalID] == 1)
    {
        CulledGrassBuffer[ScanBuffer[globalID]] = PositionsBuffer[globalID];
    }
}
